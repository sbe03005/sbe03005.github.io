---
layout: post
title: Node.js 교과서 1장을 공부하고
subheading: Node.js 교과서 1장을 공부하고
author: sbe03005
categories: Node.js 교과서
banner: https://bit.ly/32PAjtM
tags: Node.js 교과서
sidebar: []
---

# Node.js 교과서 1장을 공부하고



2월 15일 입사를 하고 일이 바빠 블로그를 못하고 지내다가, 

슬슬 다른 공부가 하고 싶어져서 기존에 활동하던 동아리에 활동 신청을 하고 Node.js 공부를 하게 되었다.



⚠️ 본 포스팅은 매주 Node.js를 공부하고, 동아리 스터디원들과 함께 스터디한 내용을 정리하는 곳입니다.

⚠️ 모든 내용을 기록하려고 하기 보다는 함축하고 필요한 내용만 작성하고 있습니다.



## 자바스크립트 런타임

1. Node.js는 Chrome V8 엔진으로 빌드된 js 런타임
2. V8과 더불어 libuv 라이브러리 사용
3. libuv 라이브러리는 노드의 특성인 이벤트 기반, 논 블로킹 I/O 모델을 구현하고 있음



## 이벤트 기반

1. 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때, 이벤트 리스너에 콜백 함수를 등록한다.

   - ex) 클릭 이벤트 리스너에 경고창을 띄우는 콜백을 등록해두면, 해당 이벤트가 발생할 때마다 콜백 함수로 경고창이 뜨는 것

2. 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면, 대기

   

3. 용어 정리

   - **이벤트 루프**: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당. 노드가 종료될 때까지 이벤트 러리를 위한 작업을 반복하므로 루프라고 부름

   - **백그라운드**: setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳. js가 아닌 다른 언어로 작성된 프로그램. 여러 작업이 동시에 실행될 수 있다.

   - **태스크 큐**: 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보냄. 정해진 순서대로 콜백들이 줄서 있어, 콜백 큐라고도 부름, 특정 경우에는 순서가 바뀌기도 함.

     

4. 예시:

   1. setTimeout 실행 시 콜백 run은 백그라운드로 보냄.
   2. 백그라운드에서 3초 후 태그크 큐로 보냄
   3. 태스크 큐에서 그때서야 run에 해당하는 작업을 호출 스택으로 올림
   4. 주의: 호출 스택이 비어있어야 큐에서 run을 가져옴 (setTimeout으로 올린 시간이 정확하지 않을 수 있는 이유)



## 논 블로킹 I/O



1. 논 블로킹이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것
2. 반대로 블로킹은 이전 작업이 완료되어야만 다음 작업을 진행하는 것
3. 논 블로킹 방식으로 코드를 작성하더라도 실행 순서만 바꾸는 것이지 동시성이 활성화된 것이 아니기 때문에 전체 소요시간을 짧아지지 않는다.
   - 하지만 이러한 작업이 의미없는 것은 아님.
   - 순서를 바꿔줌으로써 간단한 작업을 얼른 처리하고 대기상황을 막을 수 있다는 장점이 있다.



## 싱글 스레드



1. 노드가 싱글 스레드라고 하지만, 실제로 진짜 싱글 스레드는 아님.
   - 우리가 제어할 수 있는 스레드가 하나라서 싱글 스레드라고 부름
2. 그렇기 때문에 블로킹이 심하게 일어나는 작업만 아니면 충분히 처리가 가능하다.
3. 싱글 스레드 + 블로킹
   - 점원 한명이 주문을 받고, 요리가 나오면 서빙함.
   - 이 후에 다음 주문을 받음
   - **이런 구조는 다음 손님은 이전 손님의 요리가 나올 때까지 아무것도 못하고 대기해야함**
4. 싱글 스레드 + 논 블로킹
   - 점원 한명이 여러 주문을 동시에 받을 수 있음
   - **그러나 요리시간이 너무 길거나 점원이 아파서 쓰러지면 문제가 발생함**
5. 멀티 스레드 + 논 블로킹
   - 점원 한명에게 문제가 발생해도 다른 점원이 있기 때문에 문제가 발생하진 않음
   - **그러나 일이 급격하게 늘어나거나 줄어들때, 고용과 해고를 하는데 비용이 발생**



## 서버로서의 노드



1. 작은 데이터를 실시간으로 주고 받는데 적합함
2. CPU연산이 많이 요구되는 서버로는 적합하지 않음
3. 멀티 스레드 방식보다는 쉬우나, 싱글 스레드이므로 멈추지 않도록 관리가 필요함